package calc;

import java.math.BigDecimal;
//import java.math.BigInteger;
import java.math.MathContext;
import java.math.RoundingMode;

/*
 * . Quebrar os algorítimos possíveis para multi thread
 *
 * Calculo é imutável, pode ser utilizado em multi thread
 */
public class Calculo {
	private int DELTA_PRECISAO = 10;
	private int PRECISAO_DEFAULT = 20;
	private MathContext mc;
	private MathContext mcAux;
	private BigDecimal PI = null;
	private BigDecimal LN2 = null;
	private BigDecimal SQRT2 = null;
	

	public Calculo() {
		super();
		this.mc = new MathContext(PRECISAO_DEFAULT, RoundingMode.HALF_EVEN);
		this.mcAux = new MathContext(mc.getPrecision() + DELTA_PRECISAO, RoundingMode.HALF_EVEN);
	}
	

	public Calculo (MathContext mc) {
		super();
		// TODO analisar quando precisão for zero ou valor muito grande
		if(mc.getPrecision() == 0)
			throw new IllegalArgumentException("Calculadora não realiza cálculos com precisão ilimitada.");
		if(mc.getPrecision() > 5010)
			throw new IllegalArgumentException("Calculadora não realiza cálculos com precisão > 5000.");
		this.mc = mc;
		this.mcAux = new MathContext(mc.getPrecision() + DELTA_PRECISAO, mc.getRoundingMode());
	}


	protected MathContext getContexto() {
		return this.mc;
	}


	private MathContext getContextoAux() {
		return this.mcAux;
	}
	
	
	private BigDecimal getPI() {
		if (PI == null)
			PI = computePi();
		return PI;
	}

	
	private BigDecimal getLn2() {
		if (LN2 == null)
			LN2 = computeLn2();
		return LN2;
	}
	
	
	private BigDecimal getSqrt2() {
		if (SQRT2 == null)
			SQRT2 = computeSqrt(new BigDecimal(2));
		return SQRT2;
	}
	

	private int getIteracoesTrig (int precisao) {
		if (precisao <= 20)
			return 20;
		if (precisao <= 220)
			return precisao;
		if (precisao <= 440)
			return 220;
		return (int) (precisao/2);
	}
	
	
	private int getIteracoesAtan (int precisao) {
		if (precisao <= 10)
			return 12;
		return (int) (1.2*precisao);
	}
	
	
	private int getIteracoesAsin (int precisao) {
		if (precisao <= 10)
			return 33;
		return (int) (3.33*precisao);
	}
	
	
	private int getIteracoesLn (int precisao) {
		return (int) (2.1*precisao);
	}
	
	
	private int getIteracoesExp (int precisao) {
		if (precisao <= 19)
			return 19;
		if (precisao <= 190)
			return precisao;
		if (precisao <= 380)
			return 190;
		return (int) (precisao/2);
	}
	
	
	private int getIteracoesPi (int precisao) {
		if (precisao < 10)
			return 4;
		return (int) (0.4*precisao);
	}
	
	
	private int getIteracoesE (int precisao) {
		if (precisao <= 28)
			return 28;
		if (precisao <= 272)
			return precisao;
		if (precisao <= 544)
			return 272;
		return (int) (precisao/2);
	}
	
	
	private int getIteracoesPhi (int precisao) {
		return (int) (1.7*precisao);
	}
	
	
	public BigDecimal computeAddition(BigDecimal oper1, BigDecimal oper2){
		return oper1.add(oper2);
	}
	
	
	public BigDecimal computeSubtraction(BigDecimal oper1, BigDecimal oper2){
		return oper1.subtract(oper2);
	}
	
	
	public BigDecimal computeMultiplication(BigDecimal oper1, BigDecimal oper2){
		return oper1.multiply(oper2);
	}
	
	
	public BigDecimal computeDivision(BigDecimal numerador, BigDecimal denominador){
		if(denominador.compareTo(BigDecimal.ZERO) == 0)
			throw new IllegalArgumentException("Math ERROR");
		return numerador.divide(denominador, getContextoAux());
	}
	
	
	public BigDecimal computeSin (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.RADIANS)) {
			BigDecimal resto = angulo.remainder(pi.multiply(new BigDecimal(2)));
			resto = resto.round(getContextoAux());
			BigDecimal quartoDePi = pi.divide(new BigDecimal(4));
			BigDecimal resultado;
			if (resto.compareTo(quartoDePi) < 0) {
				resultado = sin(resto);
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(3))) < 0) {
				resultado = cos(pi.divide(new BigDecimal(2)).subtract(resto));
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(5))) < 0) {
				resultado = sin(pi.subtract(resto));
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(7))) < 0) {
				resultado = cos(pi.multiply(new BigDecimal(3)).divide(new BigDecimal(2)).subtract(resto)).negate(); 
			} else
				resultado = sin(pi.multiply(new BigDecimal(2)).subtract(resto)).negate();
			return resultado;
		}
		return computeSin(grausParaRad(angulo), UnidadeDeAngulo.RADIANS);
	}


	public BigDecimal computeCos (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.RADIANS)) {
			BigDecimal resto = angulo.remainder(pi.multiply(new BigDecimal(2)));
			resto = resto.round(getContextoAux());
			BigDecimal quartoDePi = pi.divide(new BigDecimal(4));
			BigDecimal resultado;
			if (resto.compareTo(quartoDePi) < 0) {
				resultado = cos(resto);
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(3))) < 0) {
				resultado = sin(pi.divide(new BigDecimal(2)).subtract(resto));
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(5))) < 0) {
				resultado = cos(pi.subtract(resto)).negate();
			} else if (resto.compareTo(quartoDePi.multiply(new BigDecimal(7))) < 0) {
				resultado = sin(pi.divide(new BigDecimal(2)).multiply(new BigDecimal(3)).subtract(resto)).negate(); 
			} else
				resultado = sin(pi.multiply(new BigDecimal(2)).subtract(resto)).negate();
			return resultado;
		}
		return computeCos(grausParaRad(angulo), UnidadeDeAngulo.RADIANS);
	}

	
	public BigDecimal computeCsc (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		BigDecimal resto = angulo.remainder(pi);
		if (resto.compareTo(BigDecimal.ZERO) == 0)
			throw new IllegalArgumentException("Math ERROR");
		return BigDecimal.ONE.divide(computeSin(angulo, unidade), getContextoAux());
	}
	
	
	public BigDecimal computeSec (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		BigDecimal resto = angulo.remainder(pi);
		if (resto.compareTo(pi.divide(new BigDecimal(2))) == 0)
			throw new IllegalArgumentException("Math ERROR");
		return BigDecimal.ONE.divide(computeCos(angulo, unidade), getContextoAux());
	}
	
	
	public BigDecimal computeTan (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.RADIANS)) {
			BigDecimal resto = angulo.remainder(pi);
			if (resto.compareTo(BigDecimal.ZERO) == 0)
				return BigDecimal.ZERO;
			if (resto.compareTo(pi.divide(new BigDecimal(2))) == 0)
				throw new IllegalArgumentException("Math ERROR");
		} else {
			BigDecimal resto = angulo.remainder(new BigDecimal(180));
			if (resto.compareTo(BigDecimal.ZERO) == 0)
				return BigDecimal.ZERO;
			if (resto.compareTo(new BigDecimal(90)) == 0)
				throw new IllegalArgumentException("Math ERROR");
		}
		return computeSin(angulo, unidade).divide(computeCos(angulo, unidade), getContextoAux());
	}
	
	
	public BigDecimal computeCot (BigDecimal angulo, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.RADIANS)) {
			BigDecimal resto = angulo.remainder(pi);
			if (resto.compareTo(BigDecimal.ZERO) == 0)
				throw new IllegalArgumentException("Math ERROR");
			if (resto.compareTo(pi.divide(new BigDecimal(2))) == 0)
				return BigDecimal.ZERO;
		} else {
			BigDecimal resto = angulo.remainder(new BigDecimal(180));
			if (resto.compareTo(BigDecimal.ZERO) == 0)
				throw new IllegalArgumentException("Math ERROR");
			if (resto.compareTo(new BigDecimal(90)) == 0)
				return BigDecimal.ZERO;
		}
		return computeCos(angulo, unidade).divide(computeSin(angulo, unidade), getContextoAux());
	}
	
	
	private BigDecimal grausParaRad (BigDecimal graus){
		BigDecimal pi = getPI();
		return graus.multiply(pi).divide(new BigDecimal(180), getContextoAux());
	}


	private BigDecimal sin (BigDecimal radianos) {
		int iteracoes = getIteracoesTrig(getContexto().getPrecision());
		BigDecimal resposta = BigDecimal.ZERO;
		if(radianos.equals(BigDecimal.ZERO))
			return resposta;
		int n = 1;
		BigDecimal b = radianos;
		BigDecimal y = radianos.pow(2);
		BigDecimal z = radianos.pow(4);
		BigDecimal fatorial = BigDecimal.ONE;
		while(n < iteracoes){
			BigDecimal oper1 = b.divide(fatorial, getContextoAux());
			BigDecimal oper2 = fatorial.multiply(new BigDecimal(n + 1)).multiply(new BigDecimal(n + 2), getContextoAux());
			BigDecimal oper3 = b.multiply(y).divide(oper2, getContextoAux());
			resposta = resposta.add(oper1).subtract(oper3);
			fatorial = oper2.multiply(new BigDecimal(n + 3)).multiply(new BigDecimal(n + 4), getContextoAux());
			b = b.multiply(z, getContextoAux());
			n += 4;
		}
		return resposta.round(getContextoAux());
	}


	private BigDecimal cos (BigDecimal radianos) {
		int iteracoes = getIteracoesTrig(getContexto().getPrecision());
		BigDecimal resposta = BigDecimal.ONE;
		if (radianos.equals(BigDecimal.ZERO))
			return resposta;
		int n = 2;
		BigDecimal b = radianos.pow(2);
		BigDecimal y = radianos.pow(2);
		BigDecimal z = radianos.pow(4);
		BigDecimal fatorial = new BigDecimal(2);
		while (n < iteracoes) {
			BigDecimal oper1 = b.divide(fatorial, getContextoAux());
			BigDecimal oper2 = fatorial.multiply(new BigDecimal(n + 1)).multiply(new BigDecimal(n + 2), getContextoAux());
			BigDecimal oper3 = b.multiply(y).divide(oper2, getContextoAux());
			resposta = resposta.subtract(oper1).add(oper3);
			fatorial = oper2.multiply(new BigDecimal(n + 3)).multiply(new BigDecimal(n + 4), getContextoAux());
			b = b.multiply(z, getContextoAux());
			n += 4;
		}
		return resposta.round(getContextoAux());
	}


	public BigDecimal computeSinh (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ZERO;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeSinh(x.negate()).negate();
		BigDecimal exp = computeExponential(x);
		BigDecimal num = exp.pow(2).subtract(BigDecimal.ONE);
		return num.divide(exp.multiply(new BigDecimal(2)), getContextoAux());
	}
	
	
	public BigDecimal computeCosh (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ONE;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeCosh(x.negate());
		BigDecimal exp = computeExponential(x);
		BigDecimal num = exp.pow(2).add(BigDecimal.ONE);
		return num.divide(exp.multiply(new BigDecimal(2)), getContextoAux());
	}
	
	
	public BigDecimal computeTanh (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ZERO;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeTanh(x.negate()).negate();
		BigDecimal exp = computeExponential(x).pow(2);
		BigDecimal num = exp.subtract(BigDecimal.ONE);
		BigDecimal den = exp.add(BigDecimal.ONE);
		return num.divide(den, getContextoAux());
	}
	
	
	public BigDecimal computeCsch (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			throw new IllegalArgumentException("Math ERROR");
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeCsch(x.negate()).negate();
		BigDecimal exp = computeExponential(x);
		BigDecimal den = exp.pow(2).subtract(BigDecimal.ONE);
		return exp.multiply(new BigDecimal(2)).divide(den, getContextoAux());
	}
	
	
	public BigDecimal computeSech (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ONE;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeSech(x.negate());
		BigDecimal exp = computeExponential(x);
		BigDecimal den = exp.pow(2).add(BigDecimal.ONE);
		return exp.multiply(new BigDecimal(2)).divide(den, getContextoAux());
	}
	

	public BigDecimal computeCoth (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			throw new IllegalArgumentException("Math ERROR");
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeCoth(x.negate()).negate();
		BigDecimal exp = computeExponential(x).pow(2);
		BigDecimal num = exp.add(BigDecimal.ONE);
		BigDecimal den = exp.subtract(BigDecimal.ONE);
		return num.divide(den, getContextoAux());
	}
	
	
	public BigDecimal computeAtan (BigDecimal x, UnidadeDeAngulo unidade) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ZERO;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeAtan(x.negate(), unidade).negate();
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.DEGREE))
			return radParaGraus(computeAtan(x, UnidadeDeAngulo.RADIANS));
		if (x.compareTo(BigDecimal.ONE) == 0)
			return pi.divide(new BigDecimal(4));
		BigDecimal sqrt2 = getSqrt2();
		if (x.compareTo(BigDecimal.ONE.add(sqrt2)) > 0)
			return pi.divide(new BigDecimal(2)).subtract(computeAtan(BigDecimal.ONE.divide(x, getContextoAux()), UnidadeDeAngulo.RADIANS));
		if (x.compareTo(BigDecimal.ONE) > 0)
			return pi.divide(new BigDecimal(4)).add(computeAtan((x.subtract(BigDecimal.ONE)).divide(x.add(BigDecimal.ONE), getContextoAux()), UnidadeDeAngulo.RADIANS));
		if (x.compareTo(sqrt2.subtract(BigDecimal.ONE)) > 0)
			return pi.divide(new BigDecimal(4)).subtract(computeAtan((BigDecimal.ONE.subtract(x)).divide(x.add(BigDecimal.ONE), getContextoAux()), UnidadeDeAngulo.RADIANS));
		return atan(x);
	}
	
	
	private BigDecimal atan (BigDecimal x) {
		int iteracoes = getIteracoesAtan(getContexto().getPrecision());
		int n = 0;
		BigDecimal y = x.pow(2).divide(BigDecimal.ONE.add(x.pow(2)), getContextoAux());
		BigDecimal resposta = x.divide(BigDecimal.ONE.add(x.pow(2)), getContextoAux());
		BigDecimal fator = resposta;
		while (n < iteracoes) {
			n += 1;
			fator = fator.multiply(new BigDecimal(2*n)).multiply(y).divide(BigDecimal.ONE.add(new BigDecimal(2*n)), getContextoAux());
			resposta = resposta.add(fator);
		}
		return resposta.round(getContextoAux());
	}
	
	
	public BigDecimal computeAsin (BigDecimal x, UnidadeDeAngulo unidade) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ZERO;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return computeAsin(x.negate(), unidade).negate();
		if (x.compareTo(BigDecimal.ONE) > 0)
			throw new IllegalArgumentException("Math ERROR");
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.DEGREE))
			return radParaGraus(computeAsin(x, UnidadeDeAngulo.RADIANS));
		BigDecimal sqrt2 = getSqrt2();
		if (x.compareTo(BigDecimal.ONE.divide(sqrt2, getContextoAux())) > 0)
			return pi.divide(new BigDecimal(2)).subtract(computeAsin(computeSqrt(BigDecimal.ONE.subtract(x.pow(2))), UnidadeDeAngulo.RADIANS));
		return asin(x);
	}

	
	//Só aceita até 6900 algarismos
	private BigDecimal asin (BigDecimal x) {
		int iteracoes = getIteracoesAsin(getContexto().getPrecision());
		int n = 0;
		BigDecimal y = x.pow(2);
		BigDecimal fator = x;
		BigDecimal resposta = x;
		while (n < iteracoes) {
			n += 1;
			fator = fator.multiply(y.multiply(new BigDecimal(2*n - 1).pow(2))).divide(new BigDecimal(2*n*(2*n + 1)), getContextoAux());
			resposta = resposta.add(fator);
		}
		return resposta.round(getContextoAux());
	}
	
	
	public BigDecimal computeAcos (BigDecimal x, UnidadeDeAngulo unidade) {
		if (x.compareTo(BigDecimal.ONE) == 0)
			return BigDecimal.ZERO;
		if (unidade.equals(UnidadeDeAngulo.DEGREE))
			return new BigDecimal(90).subtract(computeAsin(x, UnidadeDeAngulo.DEGREE));
		BigDecimal pi = getPI();
		return pi.divide(new BigDecimal(2), getContextoAux()).subtract(computeAsin(x, UnidadeDeAngulo.RADIANS));
	}
	
	
	public BigDecimal computeAcsc (BigDecimal x, UnidadeDeAngulo unidade) {
		if (x.abs().compareTo(BigDecimal.ONE) < 0)
			throw new IllegalArgumentException("Math ERROR");
		return computeAsin(BigDecimal.ONE.divide(x, getContextoAux()), unidade);
	}
	
	
	public BigDecimal computeAsec (BigDecimal x, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.DEGREE))
			return radParaGraus(computeAsec(x, UnidadeDeAngulo.RADIANS));
		if (x.compareTo(BigDecimal.ONE.negate()) <= 0)
			return pi.subtract(computeAtan(computeSqrt(x.pow(2).subtract(BigDecimal.ONE)), UnidadeDeAngulo.RADIANS));
		if (x.compareTo(BigDecimal.ONE) >= 0)
			return computeAtan(computeSqrt(x.pow(2).subtract(BigDecimal.ONE)), UnidadeDeAngulo.RADIANS);
		throw new IllegalArgumentException("Math ERROR");
	}
	
	
	public BigDecimal computeAcot (BigDecimal x, UnidadeDeAngulo unidade) {
		BigDecimal pi = getPI();
		if (unidade.equals(UnidadeDeAngulo.DEGREE))
			return radParaGraus(computeAcot(x, UnidadeDeAngulo.RADIANS));
		if (x.compareTo(BigDecimal.ZERO) < 0)
			return pi.divide(new BigDecimal(-2)).subtract(computeAtan(x, UnidadeDeAngulo.RADIANS));
		return pi.divide(new BigDecimal(2)).subtract(computeAtan(x, UnidadeDeAngulo.RADIANS));
	}
	
	
	private BigDecimal radParaGraus (BigDecimal rad){
		BigDecimal pi = getPI();
		return rad.multiply(new BigDecimal(180)).divide(pi, getContextoAux());
	}

	
	public BigDecimal computeAsinh (BigDecimal x) {
		return asinh(x);
	}
	
	
	public BigDecimal computeAcosh (BigDecimal x) {
		if (x.compareTo(BigDecimal.ONE) < 0)
			throw new IllegalArgumentException("Math ERROR");
		return acosh(x);
	}
	
	
	public BigDecimal computeAtanh (BigDecimal x) {
		if (x.abs().compareTo(BigDecimal.ONE) >= 0)
			throw new IllegalArgumentException("Math ERROR");
		return atanh(x);
	}

	
	public BigDecimal computeAcsch (BigDecimal x) {
		return asinh(BigDecimal.ONE.divide(x, getContextoAux()));
	}
	
	
	public BigDecimal computeAsech (BigDecimal x) {
		if (x.compareTo(BigDecimal.ONE) > 0 || x.compareTo(BigDecimal.ZERO) <= 0)
			throw new IllegalArgumentException("Math ERROR");
		return acosh(BigDecimal.ONE.divide(x, getContextoAux()));
	}
	
	
	public BigDecimal computeAcoth (BigDecimal x) {
		if (x.abs().compareTo(BigDecimal.ONE) <= 0)
			throw new IllegalArgumentException("Math ERROR");
		return atanh(BigDecimal.ONE.divide(x, getContextoAux()));
	}
	
	
	private BigDecimal asinh (BigDecimal x) {
		return computeLn(x.add(computeSqrt(x.pow(2).add(BigDecimal.ONE))));
	}
	
	
	private BigDecimal acosh (BigDecimal x) {
		return computeLn(x.add(computeSqrt(x.pow(2).subtract(BigDecimal.ONE))));
	}
	
	
	private BigDecimal atanh (BigDecimal x) {
		return computeLn((x.add(BigDecimal.ONE)).divide(BigDecimal.ONE.subtract(x), getContextoAux())).divide(new BigDecimal(2), getContextoAux());
	}
		
	
	public BigDecimal computePower (BigDecimal x, BigDecimal y) {
		if (x.compareTo(BigDecimal.ZERO) == 0) {
			if (y.compareTo(BigDecimal.ZERO) == 0)
				throw new IllegalArgumentException("Math ERROR");
			return BigDecimal.ZERO;
		}
		if (x.compareTo(BigDecimal.ZERO) < 0) {
			if (y.scale() > 0)
				throw new IllegalArgumentException("Math ERROR");
			if (x.compareTo(BigDecimal.ONE.negate()) == 0)
				return BigDecimal.ONE.subtract(new BigDecimal(2).multiply(y.remainder(new BigDecimal(2))));
			return computePower(x.negate(), y).multiply(BigDecimal.ONE.subtract(new BigDecimal(2).multiply(y.remainder(new BigDecimal(2)))));
		}
		if (x.compareTo(BigDecimal.ONE) == 0)
			return BigDecimal.ONE;
		if (y.compareTo(new BigDecimal(2).pow(30)) > 0)
			return computePower(x, y.divide(new BigDecimal(8))).pow(8, getContextoAux());
		return x.pow(y.intValue(), getContextoAux()).multiply(computeExponential(y.subtract(new BigDecimal(y.intValue())).multiply(computeLn(x), getContextoAux())), getContextoAux());
	}
	

	public BigDecimal computeLn (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) <= 0)
			throw new IllegalArgumentException("Math ERROR");
		BigDecimal dois = new BigDecimal(2);
		if (x.compareTo(dois) == 0)
			return getLn2();
		if (x.compareTo(new BigDecimal(0.5)) < 0)
			return computeLn(BigDecimal.ONE.divide(x, getContextoAux())).negate();
		BigDecimal ln2 = getLn2();
		BigDecimal exp2 = BigDecimal.ONE;
		int k = 0;
		while (exp2.compareTo(x) < 0) {
			exp2 = exp2.multiply(dois);
			k += 1;
		}
		return ln2.multiply(new BigDecimal(k)).add(ln(x.divide(exp2))).round(getContextoAux());
	}
	
	
	private BigDecimal ln (BigDecimal x) {
		int iteracoes = getIteracoesLn(getContexto().getPrecision());
		if (x.compareTo(BigDecimal.ONE) == 0)
			return BigDecimal.ZERO;
		int n = 1;
		BigDecimal s = (x.subtract(BigDecimal.ONE)).divide(x.add(BigDecimal.ONE), getContextoAux());
		BigDecimal y = s.pow(2);
		BigDecimal resposta = s;
		while (n < iteracoes) {
			n += 2;
			s = s.multiply(y, getContextoAux());
			resposta = resposta.add(s.divide(new BigDecimal(n), getContextoAux()));
		}
		return resposta.multiply(new BigDecimal(2));
	}
	
	
	public BigDecimal computeLog10 (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) <= 0)
			throw new IllegalArgumentException("Math ERROR");
		return computeLn(x).divide(computeLn(BigDecimal.TEN), getContextoAux());
	}
	
	
	public BigDecimal computeSqrt (BigDecimal x) {
		if (x.compareTo(BigDecimal.ZERO) == 0)
			return BigDecimal.ZERO;
		if (x.compareTo(BigDecimal.ZERO) < 0)
			throw new IllegalArgumentException("Math ERROR");
		if (x.compareTo(BigDecimal.ONE) == 0)
			return BigDecimal.ONE;
		return computeExponential(computeLn(x).divide(new BigDecimal(2)));
	}
	
	
	public BigDecimal computeExponential (BigDecimal x) {
		int iteracoes = getIteracoesExp(getContexto().getPrecision());
		if (x.compareTo(BigDecimal.ZERO) < 0) {
			return BigDecimal.ONE.divide(computeExponential(x.negate()), getContextoAux());
		}
		if (x.compareTo(BigDecimal.ZERO) == 0) {
			return BigDecimal.ONE;
		}
		BigDecimal ln2 = getLn2();
		BigDecimal[] array = x.divideAndRemainder(ln2);
		BigDecimal restExp = array[1];
		BigDecimal exp = BigDecimal.ONE;
		BigDecimal fact = BigDecimal.ONE;
		int n = 1;
		while (n < iteracoes) {
			fact = fact.multiply(new BigDecimal(n), getContextoAux());
			exp = exp.add(restExp.divide(fact, getContextoAux()));
			restExp = restExp.multiply(array[1], getContextoAux());
			n += 1;
		}
		if (x.compareTo(new BigDecimal(2).pow(29)) > 0)
			return computeExponential(x.divide(new BigDecimal(2))).pow(2, getContextoAux());
		return exp.multiply(new BigDecimal(2).pow(array[0].intValue(), getContextoAux()), getContextoAux());		
	}
	
	
	public BigDecimal computePi() {
		int iteracoes = getIteracoesPi(getContexto().getPrecision());
		int n = 0;
		BigDecimal resposta = BigDecimal.ZERO;
		BigDecimal a = new BigDecimal(-32);
		BigDecimal b = new BigDecimal(-1);
		BigDecimal c = new BigDecimal(256);
		BigDecimal d = new BigDecimal(-64);
		BigDecimal e = new BigDecimal(-4);
		BigDecimal exp2 = b.divide(new BigDecimal(1024), getContextoAux());
		while (n < iteracoes) {
			BigDecimal oper1 = a.divide(new BigDecimal(4*n + 1), getContextoAux()).add(b.divide(new BigDecimal(4*n + 3), getContextoAux()));
			BigDecimal oper2 = c.divide(new BigDecimal(10*n + 1), getContextoAux()).add(d.divide(new BigDecimal(10*n + 3), getContextoAux()));
			BigDecimal oper3 = e.divide(new BigDecimal(10*n + 5), getContextoAux()).add(e.divide(new BigDecimal(10*n + 7), getContextoAux())).add(BigDecimal.ONE.divide(new BigDecimal(10*n + 9), getContextoAux()));
			resposta = resposta.add(exp2.pow(n).multiply(oper1.add(oper2).add(oper3)));
			n += 1;
		}
		return resposta.divide(new BigDecimal(64), getContextoAux());
	}

	
	public BigDecimal computeE () {
			int iteracoes = getIteracoesE(getContexto().getPrecision());
			int n = 3;
			BigDecimal num = BigDecimal.ONE;
			BigDecimal den = new BigDecimal(2);
			while (n < iteracoes) {
				BigDecimal a = new BigDecimal(n);
				num = num.multiply(a, getContextoAux()).add(BigDecimal.ONE);
				den = den.multiply(a, getContextoAux());
				n += 1;
			}
			return num.divide(den, getContextoAux()).add(new BigDecimal(2));
	}

	
	private BigDecimal computeLn2 () {
			int iteracoes = getIteracoesLn(getContexto().getPrecision());
			int n = 1;
			BigDecimal num = BigDecimal.ONE;
			BigDecimal den = new BigDecimal(3);
			BigDecimal nove = new BigDecimal(9);
			BigDecimal m = BigDecimal.ONE;
			while (n < iteracoes) {
				n += 2;
				BigDecimal a = new BigDecimal(n);
				num = num.multiply(a).multiply(nove).add(m);
				den = den.multiply(a).multiply(nove);
				m = m.multiply(a);
			}
			return num.multiply(new BigDecimal(2)).divide(den, getContextoAux());
	}

	
	public BigDecimal computePhi () {
			int iteracoes = getIteracoesPhi(getContexto().getPrecision());
			int n = 1;
			BigDecimal resposta = new BigDecimal(13).divide(new BigDecimal(8));
			BigDecimal ft = new BigDecimal(-1).divide(new BigDecimal(128));
			while (n < iteracoes) {
				resposta = resposta.add(ft);
				ft = ft.multiply(new BigDecimal(-2*n - 1)).divide(new BigDecimal(8*n + 16), getContextoAux());
				n += 1;
			}
			return resposta.round(getContextoAux());
	}
	
	
	//só funciona até 10^18
	public boolean isPrime (BigDecimal N) {
		long n = N.longValue();
		if (N.compareTo(new BigDecimal(n)) != 0)
			return false;
		if (n == 2 || n == 3)
			return true;
		if (n < 2 || n%2 == 0)
			return false;
		if (n < 9)
			return true;
		if (n%3 == 0)
			return false;
		int k = 5;
		long root = computeSqrt(N).longValue();
		while (k <= root) {
			if (n%k == 0)
				return false;
			if (n%(k+2) == 0)
				return false;
			k += 6;
		}
		return true;
	}
	
}
